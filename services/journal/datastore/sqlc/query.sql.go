// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package datastore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createJournalTransaction = `-- name: createJournalTransaction :one
INSERT INTO journal (
  id, transcation_date, account_number_credit, account_number_debit, 
  amount_credit, amount_debit, type_transaction, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, transcation_date, account_number_credit, account_number_debit, amount_credit, amount_debit, type_transaction, created_at
`

type createJournalTransactionParams struct {
	ID                  int32
	TranscationDate     pgtype.Timestamp
	AccountNumberCredit pgtype.Text
	AccountNumberDebit  pgtype.Text
	AmountCredit        pgtype.Numeric
	AmountDebit         pgtype.Numeric
	TypeTransaction     pgtype.Text
	CreatedAt           pgtype.Timestamp
}

func (q *Queries) createJournalTransaction(ctx context.Context, arg createJournalTransactionParams) (Journal, error) {
	row := q.db.QueryRow(ctx, createJournalTransaction,
		arg.ID,
		arg.TranscationDate,
		arg.AccountNumberCredit,
		arg.AccountNumberDebit,
		arg.AmountCredit,
		arg.AmountDebit,
		arg.TypeTransaction,
		arg.CreatedAt,
	)
	var i Journal
	err := row.Scan(
		&i.ID,
		&i.TranscationDate,
		&i.AccountNumberCredit,
		&i.AccountNumberDebit,
		&i.AmountCredit,
		&i.AmountDebit,
		&i.TypeTransaction,
		&i.CreatedAt,
	)
	return i, err
}

const getListTransaction = `-- name: getListTransaction :many
SELECT id, transcation_date, account_number_credit, account_number_debit, amount_credit, amount_debit, type_transaction, created_at FROM journal order by created_at asc
`

func (q *Queries) getListTransaction(ctx context.Context) ([]Journal, error) {
	rows, err := q.db.Query(ctx, getListTransaction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Journal
	for rows.Next() {
		var i Journal
		if err := rows.Scan(
			&i.ID,
			&i.TranscationDate,
			&i.AccountNumberCredit,
			&i.AccountNumberDebit,
			&i.AmountCredit,
			&i.AmountDebit,
			&i.TypeTransaction,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByCondition = `-- name: getTransactionByCondition :one
SELECT id, transcation_date, account_number_credit, account_number_debit, amount_credit, amount_debit, type_transaction, created_at FROM journal
WHERE account_number_credit = $1 or account_number_debit = $2
`

type getTransactionByConditionParams struct {
	AccountNumberCredit pgtype.Text
	AccountNumberDebit  pgtype.Text
}

func (q *Queries) getTransactionByCondition(ctx context.Context, arg getTransactionByConditionParams) (Journal, error) {
	row := q.db.QueryRow(ctx, getTransactionByCondition, arg.AccountNumberCredit, arg.AccountNumberDebit)
	var i Journal
	err := row.Scan(
		&i.ID,
		&i.TranscationDate,
		&i.AccountNumberCredit,
		&i.AccountNumberDebit,
		&i.AmountCredit,
		&i.AmountDebit,
		&i.TypeTransaction,
		&i.CreatedAt,
	)
	return i, err
}
